<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Class for performing DataPlus specific actions on a db.
 * @package mod_dataplus
 * @copyright 2015 The Open University
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
require_once("sqlite3_db.php");
require_once("locallib.php");

class sqlite3_db_dataplus extends sqlite3_db {

    // Version of the DataPlus db generated by this code.
    private $version = 1.209;
    private $nextrecordid = 0;

    /**
     * @param boolean $lock
     * @param string $path
     */
    public function __construct($lock = false, $path = null, $import = false) {
        parent::__construct($lock, $path, $import);

        if ($import) {
            if (!$this->validate_database()) {
                throw new Exception('The imported file is not a valid DataPlus database.');
            }
        }
        // If this database did not previously exist, add the supporting columns and tables required.
        if (!$this->table_exists('content')) {
            $this->setup_tables();
        }

        $version = $this->needs_upgrade();

        if ($version !== false) {
            if (!$this->upgrade($version)) {
                throw new Exception('DataPlus database upgrade failed.');
            }
        }
    }


    /**
     * Returns the version of the DataPlus db created by this class
     *
     * @return float
     */
    public function get_version() {
        return $this->version;
    }


    /**
     * returns the information required for a standard primary key
     *
     * @return array
     */
    private function define_basic_columns() {
        $columns = array();

        $columns[0] = new stdClass();
        $columns[0]->name = 'id';
        $columns[0]->type = 'integer';
        $columns[0]->primary_key = true;
        $columns[0]->autoincrement = true;
        $columns[0]->notnull = true;
        $columns[0]->label = get_string('id', 'dataplus');
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        return $columns;
    }


    /**
     * umbrella for setting up all the tables and columns needed for a DataPlus database.
     * These tables record information a content table for storing user data with auto
     * generated supporting fields(creator, last user and group info), a table for recording
     * information in the columns in other tables (columns) - this is necessary due to shortcomings
     * in the support for pragma is SQLite, and a templates table for user templates
     */
    private function setup_tables() {
        $supportingcols = $this->detail_content_table_supporting_columns();

        $this->create_table("content", $supportingcols);

        $column = array();

        $column[0] = new stdClass();
        $column[0]->name = 'name';
        $column[0]->value = 'id';

        $column[1] = new stdClass();
        $column[1]->name = 'label';
        $column[1]->value = 'id';

        $column[2] = new stdClass();
        $column[2]->name = 'type';
        $column[2]->value = "integer";

        $column[3] = new stdClass();
        $column[3]->name = 'primary_key';
        $column[3]->value = 1;

        $column[4] = new stdClass();
        $column[4]->name = 'autoincrement';
        $column[4]->value = 1;

        $column[5] = new stdClass();
        $column[5]->name = 'not_null';
        $column[5]->value = 1;

        $column[6] = new stdClass();
        $column[6]->name = 'table_name';
        $column[6]->value = 'content';

        $this->insert_record("column", $column);

        foreach ($supportingcols as $supporting) {
            $column = array();
            $i = 0;

            foreach ($supporting as $name => $value) {
                $column[$i] = new stdClass();
                $column[$i]->name = $name;
                $column[$i]->value = $value;
                $i++;
            }

            $column[$i] = new stdClass();
            $column[$i]->name = 'table_name';
            $column[$i]->value = 'content';

            $this->insert_record("column", $column);
        }

        $this->setup_templates_table();
        $this->setup_supporting_table();
        $this->setup_comments_table();
        $this->set_file_db_domain();
        $this->set_file_db_version();
    }


    /**
     * Get the db version currently associated with the db file
     *
     * @return string
     */
    protected function get_file_db_version() {
        return $this->get_supporting_setting('version');
    }


    /**
     * Set the database version
     *
     * @ return boolean
     */
    public function set_file_db_version() {
        $version = $this->get_version();
        $dbversion = $this->get_file_db_version();
        return $this->set_supporting_setting('version', $version, $dbversion);
    }


     /**
      * Get the db domain currently associated with the db file
      *
      * @return string
      */
    public function get_file_db_domain() {
        return $this->get_supporting_setting('domain');
    }


    /**
     * Sets the domain under which the db was created.
     *
     * @return boolean
     */
    public function set_file_db_domain() {
        global $CFG;

        $domain = $this->get_file_db_domain();

        return $this->set_supporting_setting('domain', $CFG->wwwroot, $domain);
    }


    /**
     * Gets a supporting info setting from the supportinginfo table
     *
     * @param string name
     * @return mixes
     */
    protected function get_supporting_setting($name) {
        $columns = array('val');

        $parameters = array(new stdClass());
        $parameters[0]->name = 'variable';
        $parameters[0]->value = $name;
        $parameters[0]->operator = 'equals';

        $result = $this->query_database_single("supportinginfo", $columns, $parameters);

        if (!$result) {
            return $result;
        }

        return $result->val;
    }


    /**
     * Set supporting setting
     *
     * @param string name
     * @param string value
     * @return boolean
     */
    protected function set_supporting_setting($name, $value, $exists) {
        $columns = array();
        $columns[0] = new stdClass();
        $columns[0]->name = 'variable';
        $columns[0]->value = $name;

        $columns[1] = new stdClass();
        $columns[1]->name = 'val';
        $columns[1]->value = $value;

        if (!$exists) {
            return $this->insert_record("supportinginfo", $columns);
        }

        $parameters = array(new stdClass());
        $parameters[0]->name = 'variable';
        $parameters[0]->value = $name;
        $parameters[0]->operator = 'equals';

        return $this->update_record("supportinginfo", $columns, $parameters);
    }


    /**
     * Creates the user templates table
     *
     * @return boolean
     */
    protected function setup_templates_table() {
        $columns = $this->define_basic_columns();

        $columns[1] = new stdClass();
        $columns[1]->name = 'css';
        $columns[1]->type = 'text';

        $columns[2] = new stdClass();
        $columns[2]->name = 'js';
        $columns[2]->type = 'text';

        $columns[3] = new stdClass();
        $columns[3]->name = 'jsinit';
        $columns[3]->type = 'text';

        $columns[4] = new stdClass();
        $columns[4]->name = 'header';
        $columns[4]->type = 'text';

        $columns[5] = new stdClass();
        $columns[5]->name = 'record';
        $columns[5]->type = 'text';

        $columns[6] = new stdClass();
        $columns[6]->name = 'comments';
        $columns[6]->type = 'text';

        $columns[7] = new stdClass();
        $columns[7]->name = 'footer';
        $columns[7]->type = 'text';

        $columns[8] = new stdClass();
        $columns[8]->name = 'type';
        $columns[8]->type = 'text';

        $columns[9] = new stdClass();
        $columns[9]->name = 'sortorder';
        $columns[9]->type = 'text';

        $columns[10] = new stdClass();
        $columns[10]->name = 'group_id';
        $columns[10]->type = 'integer';

        return $this->create_table("templates", $columns);
    }


    /**
     * Creates supporting information table
     *
     * @return boolean
     */
    protected function setup_supporting_table() {
        $columns = $this->define_basic_columns();

        $columns[1] = new stdClass();
        $columns[1]->name = 'variable';
        $columns[1]->type = 'text';

        $columns[2] = new stdClass();
        $columns[2]->name = 'val';
        $columns[2]->type = 'text';

        return $this->create_table("supportinginfo", $columns);
    }


    /**
     * Creates comments table
     *
     * @return boolean
     */
    protected function setup_comments_table() {
        $columns = $this->define_basic_columns();

        $columns[1] = new stdClass();
        $columns[1]->name = 'record_id';
        $columns[1]->type = 'integer';

        $columns[2] = new stdClass();
        $columns[2]->name = 'comment';
        $columns[2]->type = 'longtext';

        $columns[3] = new stdClass();
        $columns[3]->name = 'group_id';
        $columns[3]->type = 'integer';

        $columns = array_merge($columns, $this->define_editor_columns());

        return $this->create_table("comments", $columns);
    }


    /**
     * Checks to see if the database needs to be upgraded
     *
     * @return mixed
     */
    private function needs_upgrade() {
        if (!$this->table_exists("supportinginfo")) {
            return 1.01;
        }

        $columns = array('val');

        $parameters = array(new stdClass());
        $parameters[0]->name = 'variable';
        $parameters[0]->value = 'version';
        $parameters[0]->operator = 'equals';

        $supportinginfo = $this->get_file_db_version();

        if (!$supportinginfo) {
            return 1.01;
        }

        $currentdbversion = (float) $supportinginfo;

        if ($currentdbversion < $this->get_version()) {
            return $currentdbversion;
        }

        return false;
    }


    /**
     * Checks to see if the database needs to be upgraded
     *
     * @return boolean
     */
    private function upgrade($dbversion) {
        if ($dbversion < 1.1) {
            $columns = array(new stdClass());
            $columns[0]->name = 'label';
            $columns[0]->value = get_string('id', 'dataplus');

            $columns[1] = new stdClass();
            $columns[1]->name = 'group_id';
            $columns[1]->value = '0';

            $parameters = array(new stdClass());
            $parameters[0]->name = 'name';
            $parameters[0]->value = 'id';
            $parameters[0]->operator = 'equals';

            $result = $this->update_record("column", $columns, $parameters);

            if (!$result) {
                return $result;
            }

            $result = $this->setup_supporting_table();

            if (!$result) {
                return $result;
            }

            $result = $this->add_column_query("templates", "css", "text");

            if (!$result) {
                return $result;
            }

            $result = $this->add_column_query("templates", "js", "text");

            if (!$result) {
                return $result;
            }

            $columns[0]->name = 'type';
            $columns[0]->value = 'view';

            $parameters[0]->name = 'type';
            $parameters[0]->value = 'view-template';
            $parameters[0]->operator = 'equals';

            $result = $this->update_record("templates", $columns, $parameters);

            if (!$result) {
                return $result;
            }
        }

        if ($dbversion < 1.11) {
            $result = $this->set_file_db_domain();

            if (!$result) {
                return $result;
            }
        }

        if ($dbversion < 1.2) {
            $result = $this->setup_comments_table();

            if (!$result) {
                return $result;
            }
        }

        if ($dbversion < 1.201) {
            $result = $this->add_column_query("templates", "comments", "text");

            if (!$result) {
                return $result;
            }
        }

        if ($dbversion < 1.205) {
            // Fix the content table if it has no primary key.
            $column = $this->get_column_info('content', 'id');

            if ($column->pk === "0") {
                $parameters = array(new stdClass());
                $parameters[0]->name = 'name';
                $parameters[0]->value = 'id';
                $parameters[0]->operator = 'equals';

                $idcol = $this->list_table_columns('content', $parameters);
                $idcol = $idcol[0];

                $idcol->primary_key = "1";
                $idcol->autoincrement = "1";
                $idcol->not_null = "1";

                $result = $this->alter_dataplus_column($idcol);

                if (!$result) {
                    return $result;
                }

                $records = $this->query_dataplus_database();

                return true;
            }
        }

         // Previously the following db versions were 1.202 and 1.203,
         // but there appear to have been instances of the upgrade running
         // without the sortorder column being added, at least on the tt build.
         // Therefore we seek to upgrade to 1.204 with a check to see if the sortorder
         // cols already there.
        if ($dbversion < 1.207) {
            if (!parent::check_column_exists("templates", "sortorder")) {
                $result = $this->add_column_query("templates", "sortorder", "text");

                if (!$result) {
                    return $result;
                }
            }
        }

        if ($dbversion < 1.208) {
            $result = $this->add_column_query("templates", "jsinit", "text");

            if (!$result) {
                return $result;
            }
        }

        if ($dbversion < 1.209) {
            $columns1210 = array(new stdClass());
            $columns1210[0]->name = 'label';
            $columns1210[0]->value = get_string('groupid', 'dataplus');

            $parameters1210 = array(new stdClass());
            $parameters1210[0]->name = 'name';
            $parameters1210[0]->value = 'group_id';
            $parameters1210[0]->operator = 'equals';

            $result = $this->update_record("column", $columns1210, $parameters1210);

            if (!$result) {
                return $result;
            }
        }

        return $this->set_file_db_version();
    }


    /**
     * Adds some additional supporting columns for supporting groups and form field display (also
     * a field for hiding fields, only supported in specific contexts)
     *
     * @param array
     */
    protected function get_columns_table_column_details() {
        $columns = parent::get_columns_table_column_details();

        $i = count($columns);

        $columns[$i] = new stdClass();
        $columns[$i]->name = 'form_field_type';
        $columns[$i]->type = 'text';

        $i++;

        $columns[$i] = new stdClass();
        $columns[$i]->name = 'form_field_options';
        $columns[$i]->type = 'text';

        $i++;

        $columns[$i] = new stdClass();
        $columns[$i]->name = 'hidden';
        $columns[$i]->type = 'boolean';

        $i++;

        $columns[$i] = new stdClass();
        $columns[$i]->name = 'group_id';
        $columns[$i]->type = 'integer';

        return $columns;
    }


    /**
     * details of the columns in the content table that contain information on
     * the record creator, last update and group
     *
     * @return array
     */
    public function detail_content_table_supporting_columns() {
        $basiccols = $this->define_basic_columns();

        $editorcols = $this->define_editor_columns();

        $columns = array();
        $columns[0] = new stdClass();
        $columns[0]->name = 'group_id';
        $columns[0]->label = get_string('groupid', 'dataplus');
        $columns[0]->type = 'integer';
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        return array_merge($basiccols, $editorcols, $columns);
    }


    /**
     * returns the details of the columns used to store creator information
     *
     * @return array
     */
    public function define_creator_columns() {
        $columns = array();
        $columns[0] = new stdClass();
        $columns[0]->name = 'creator';
        $columns[0]->label = get_string('creator', 'dataplus');
        $columns[0]->type = 'text';
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        $columns[1] = new stdClass();
        $columns[1]->name = 'creator_id';
        $columns[1]->label = get_string('creatorid', 'dataplus');
        $columns[1]->type = 'text';
        $columns[1]->group_id = '0';
        $columns[1]->hidden = true;

        $columns[2] = new stdClass();
        $columns[2]->name = 'created_time';
        $columns[2]->label = get_string('created', 'dataplus');
        $columns[2]->type = 'datetime';
        $columns[2]->group_id = '0';
        $columns[2]->hidden = false;

        return $columns;
    }


    /**
     * returns the details of the columns used to store creator information
     *
     * @return array
     */
    public function define_updater_columns() {
        $columns = array();
        $columns[0] = new stdClass();
        $columns[0]->name = 'last_update';
        $columns[0]->label = get_string('updater', 'dataplus');
        $columns[0]->type = 'text';
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        $columns[1] = new stdClass();
        $columns[1]->name = 'last_update_id';
        $columns[1]->label = get_string('updaterid', 'dataplus');
        $columns[1]->type = 'text';
        $columns[1]->group_id = '0';
        $columns[1]->hidden = true;

        $columns[2] = new stdClass();
        $columns[2]->name = 'last_update_time';
        $columns[2]->label = get_string('updated', 'dataplus');
        $columns[2]->type = 'datetime';
        $columns[2]->group_id = '0';
        $columns[2]->hidden = false;

        return $columns;
    }


    /**
     * Returns details of editor and updater columns
     *
     * @return array
     */
    public function define_editor_columns() {
        return array_merge($this->define_creator_columns(), $this->define_updater_columns());
    }


    /**
     * returns an array with the names of form field types and their labels
     *
     * @return array
     */
    public function get_field_types() {
        return array(
            'smalltext' => get_string('field_smalltext', 'dataplus'),
            'longtext' => get_string('field_longtext', 'dataplus'),
            'date' => get_string('field_date', 'dataplus'),
            'datetime' => get_string('field_datetime', 'dataplus'),
            'number' => get_string('field_number', 'dataplus'),
            'image' => get_string('field_image', 'dataplus'),
            'file' => get_string('field_file', 'dataplus'),
            'url' => get_string('field_url', 'dataplus'),
            'boolean' => get_string('field_boolean', 'dataplus'),
            'menusingle' => get_string('field_menusingle', 'dataplus'),
            'menumultiple' => get_string('field_menumultiple', 'dataplus'));
    }


    /**
     * gets the label for a field type
     *
     * @param string $fieldtype
     * @return mixed
     */
    public function get_field_type_description($fieldtype) {
        $types = $this->get_field_types();

        if (isset($types[$fieldtype])) {
            return $types[$fieldtype];
        } else {
            return false;
        }
    }


    /**
     * returns an array of form field types mapped to SQLite data types
     *
     * @return array
     */
    public function get_field_data_types() {
        return array(
            'smalltext' => 'text',
            'longtext' => 'text',
            'date' => 'date',
            'datetime' => 'date',
            'number' => 'integer',
            'image' => 'text',
            'file' => 'text',
            'url' => 'text',
            'boolean' => 'boolean',
            'menusingle' => 'text',
            'menumultiple' => 'text',
            'supp' => 'text');
    }


    /**
     * gets the data type for a form field type
     *
     * @param string $fieldtype
     * @return mixed
     */
    public function get_field_data_type($fieldtype) {
        $types = $this->get_field_data_types();

        if (isset($types[$fieldtype])) {
            return $types[$fieldtype];
        }

        return false;
    }


    /**
     * this is added to the end of names of additional fields used to store
     * supporting information (image alt tags, url descriptors, etc).
     *
     * Legacy - only for use to support imports from Moodle 1.9 versions.
     *
     * @return string
     */
    public function get_supporting_suffix() {
        return '000SUPP';
    }


    /**
     * returns an array of the form field types that have  addition fields
     * for supporting information
     *
     * @return array
     */
    public function get_combi_fields() {
        return array(
            'url' => 'desc',
            'image' => 'alt');
    }


    /**
     * returns an array of the names of combi fields
     *
     * @return array
     */
    public function get_combi_fields_types() {
        $fields = $this->get_combi_fields();
        $types = array();

        foreach ($fields as $type => $val) {
            $types[] = $type;
        }

        return $types;
    }


    /**
     * returns a valid name for a supporting field
     *
     * @param string $parentname
     * @param string $type
     * @return mixed
     */
    public function get_supporting_field_name($parentname, $type) {
        $fields = $this->get_combi_fields();

        if (!isset($fields[$type])) {
            return false;
        }

        $extra = $fields[$type];
        $name = substr(preg_replace('/[^a-zA-Z0-9]/', '', $parentname), 0, 16);

        return $extra.$name;
    }


    /**
     * list the supporting columns in the content table
     *
     * @param boolean $inchidden
     * @return array
     */
    public function list_content_table_supporting_columns($inchidden = false) {
        $cols = $this->detail_content_table_supporting_columns();
        $list = array();

        foreach ($cols as $col) {
            if (!$inchidden && $col->hidden) {
                continue;
            }

            $list[] = $col->name;
        }

        return $list;
    }


    /**
     * list the columns in the content table.  $parameters can be specified for the query.
     * Supporting fields can be included/ommitted
     *
     * @param boolean $incsupporting
     * @param array $parameters
     * @return array
     */
    public function list_dataplus_table_columns($incsupporting = false,
                                                $parameters = array()) {
        if (!$incsupporting) {
            $i = count($parameters);
            $parameters[$i] = new stdClass();
            $parameters[$i]->name = 'form_field_type';
            $parameters[$i]->value = 'supp';
            $parameters[$i]->operator = 'notequal';
        }

        $columns = $this->list_table_columns('content', $parameters);

        return $columns;
    }


    /**
     * list the columns in the content table as an array.  $parameters can be specified
     * for the query.  Supporting fields can be included/ommitted
     *
     * @param boolean $incsupporting
     * @param array $parameters
     * @return unknown
     */
    public function list_dataplus_table_columns_array($incsupporting = false,
                                                      $parameters = array()) {
        $columns = $this->list_dataplus_table_columns($incsupporting, $parameters);
        $output = array();

        foreach ($columns as $r) {
            if (empty($r->label) || empty($r->name)) {
                continue;
            }

            $output[$r->name] = $r->label;
        }

        return $output;
    }


    /**
     * returns an array with the names of the columns from the content table
     *
     * @param boolean $incsupporting
     * @return array
     */
    public function list_table_columns_names($incsupporting = false) {
        $columns = $this->list_dataplus_table_columns($incsupporting);
        $names = array();

        foreach ($columns as $column) {
            $names[] = $column->name;
        }

        return $names;
    }


    /**
     * returns an array with the names of the date or datetime columns from the content table
     *
     * @param boolean $incsupporting
     * @return array
     */
    public function list_table_datetime_column_names() {
        $columns = $this->list_dataplus_table_columns();
        $names = array();

        foreach ($columns as $column) {
            if ($column->type == 'date' || $column->type == 'datetime') {
                $names[] = $column->name;
            }
        }

        return $names;
    }


    /**
     * return the name of a column from content from it's id.
     *
     * @param int $id
     * @return string
     */
    public function get_dataplus_column_field_name($id) {
        return parent::get_column_field_name('content', $id);
    }


    /**
     * returns the form_field_type of a column from it's id.
     *
     * @param int $id
     * @return mixed
     */
    public function get_column_field_type($id) {
        return $this->get_column_field('content', $id, 'form_field_type');
    }


    /**
     * check a column with a given name exists
     *
     * @param string $colname
     * @return boolean
     */
    public function check_dataplus_column_exists($colname) {
        return parent::check_column_exists('content', $colname);
    }


    /**
     * Checks the SQLite database loaded is valid for use in DataPlus.  It checks the 'content'
     * and 'templates' tables exist
     *
     * @return mixed
     */
    public function validate_database() {
        $validate = parent::validate_database();

        if ($validate !== true) {
            return $validate;
        }

        $contentexists = $this->table_exists('content');

        if (!$contentexists) {
            return false;
        }

        $templateexists = $this->table_exists('templates');

        if (!$templateexists) {
            return false;
        }
        return true;
    }


    /**
     * add a column to a table
     *
     * @param string $collabel
     * @param string $formfieldtype
     * @param string $formfieldopts
     * @param string/int $groupid
     * @return boolean
     */
    public function add_dataplus_column($collabel,
                                  $formfieldtype,
                                  $formfieldopts = null,
                                  $groupid = '0') {
        $type = $this->get_field_data_type($formfieldtype);
        $name = $this->add_column($collabel, $type);

        if ($name === false) {
            return false;
        } else {
            $columns = array(new stdClass());
            $columns[0]->name = 'form_field_type';
            $columns[0]->value = $formfieldtype;

            $columns[1] = new stdClass();
            $columns[1]->name = 'form_field_options';
            $columns[1]->value = $formfieldopts;

            $columns[2] = new stdClass();
            $columns[2]->name = 'group_id';
            $columns[2]->value = $groupid;

            $parameters = array(new stdClass());
            $parameters[0]->name = 'name';
            $parameters[0]->value = $name;
            $parameters[0]->operator = 'equals';

            $parameters[1] = new stdClass();
            $parameters[1]->name = 'table_name';
            $parameters[1]->value = 'content';
            $parameters[1]->operator = 'equals';

            $result = $this->update_record("column", $columns, $parameters);

            $combifields = $this->get_combi_fields();

            if (!empty($combifields[$formfieldtype])) {
                $result = $this->add_supporting_column($name, $formfieldtype);
            }
        }

        return $result;
    }


    /**
     * adds a supporting column for field types that require it (e.g. alt tags for images,
     * descriptors for URLs, etc)
     *
     * @param string $assocname
     * @return boolean
     */
    private function add_supporting_column($assocname, $type) {
        $label = $this->get_supporting_field_name($assocname, $type);

        if (!$label) {
            return '';
        }

        $result = $this->add_dataplus_column($label, 'supp');

        return $result;
    }


    /**
     * Delete a column identified by the column id
     *
     * @param int $colid
     * @return boolean
     */
    public function delete_dataplus_column($colid) {
        $type = $this->get_column_field_type($colid);
        $name = $this->get_dataplus_column_field_name($colid);
        $result = $this->delete_column('content', $colid);

        if (!$result) {
            return false;
        }

        if (!empty($combifields[$type])) {
            $result = $this->delete_supporting_column($name, $type);
        }

        $templates = $this->get_templates();

        foreach ($templates as $template) {
            $temp = $template->record;
            $rep = str_replace("[[{$name}]]", "", $temp);

            if (strcmp($temp, $rep) != 0) {
                $template->record = $rep;
                $vals = $this->convert_object_to_values($template);

                $this->update_template($vals);
            }
        }

        return $result;
    }


    /**
     * delete a supporting column by its name
     *
     * @param string $parentname
     * @return boolean
     */
    private function delete_supporting_column($parentname, $type) {
        $name = $this->get_supporting_field_name($parentname, $type);

        if (!$name) {
            return '';
        }

        $col = $this->get_column_details_by_name($name);
        $result = $this->delete_dataplus_column($col->id);

        return $result;
    }


    /**
     * change a columns label, type, group and/or options
     *
     * @param obj $coldetails
     * @return array
     */
    public function alter_dataplus_column($coldetails) {
        global $currentgroup;

        if (empty($coldetails->type)) {
            $coldetails->type = $this->get_field_data_type($coldetails->form_field_type);
        }

        $storedcol = $this->get_column_details($coldetails->id);

        $result = $this->alter_column('content', $coldetails);

        if ($result === "COLUMNEXISTS"  || $result === false) {
            return $result;
        }

        $update = array();
        $i = 0;
        $altertype = false;

        if ($storedcol->form_field_type !== $coldetails->form_field_type) {
            $update[$i] = new stdClass();
            $update[$i]->name  = 'form_field_type';
            $update[$i]->value = $coldetails->form_field_type;

            $i++;

            $altertype = true;
        }

        if (isset($coldetails->form_field_options)) {
            $update[$i] = new stdClass();
            $update[$i]->name = 'form_field_options';
            $update[$i]->value = $coldetails->form_field_options;
            $i++;
        }

        $update[$i] = new stdClass();
        $update[$i]->name  = 'group_id';

        if (isset($coldetails->group_id)) {
            $update[$i]->value = $coldetails->group_id;
        } else {
            $update[$i]->value = '';
        }

        $i++;

        if (count($update) > 0) {
            $parameters = array(new stdClass());
            $parameters[0]->name = 'id';
            $parameters[0]->value = $coldetails->id;
            $parameters[0]->operator = 'equals';

            $parameters[1] = new stdClass();
            $parameters[1]->name = 'table_name';
            $parameters[1]->value = 'content';
            $parameters[1]->operator = 'equals';

            $result = $this->update_record('column', $update, $parameters);

            if ($result !== true) {
                return $result;
            }
        }

        $name = $this->create_valid_object_name($coldetails->label);
        $label = $coldetails->label;

        if ($altertype) {
            // Delete supporting column if there is one.
            $formfieldtype = $storedcol->form_field_type;
            $this->delete_supporting_column($storedcol->name, $formfieldtype);
            $result = $this->add_supporting_column($name, $coldetails->form_field_type);
        } else {
            // Renames the supporting column if there is one.
            $formfieldtype = $coldetails->form_field_type;
            $result = $this->rename_supporting_column($storedcol->name, $formfieldtype, $label);
        }

        $templates = $this->get_templates();

        foreach ($templates as $template) {
            $temp = $template->record;
            $name = $this->create_valid_object_name($coldetails->label);
            $rep = str_replace("[[{$storedcol->name}]]", "[[{$name}]]", $temp);

            if (strcmp($temp, $rep) != 0) {
                $template->record = $rep;
                $vals = $this->convert_object_to_values($template);

                $this->update_template($vals);
            }
        }

        return $result;
    }


    /**
     * rename a supporting column
     *
     * @param string $assocname
     * @param string $assocnewname
     * @return boolean
     */
    public function rename_supporting_column($parentname, $type, $assocnewname) {
        $name1 = $this->get_supporting_field_name($parentname, $type);

        if (!$name1) {
            return '';
        }

        $col = $this->get_column_details_by_name($name1);

        // This deals with 1.9 imports.
        if (empty($col)) {
            $name2 = $parentname . $this->get_supporting_suffix();
            $col = $this->get_column_details_by_name($name2);
        }

        $newname = $this->get_supporting_field_name($assocnewname, $type);

        $detail = new stdClass();
        $detail->id = $col->id;
        $detail->label = $newname;
        $detail->form_field_type = 'supp';

        $result = $this->alter_dataplus_column($detail);

        return $result;
    }


    /**
     * insert a record.  Fields and there values are specified in the columns array.
     * Creator, last update and group information
     *
     * @param array $columns
     * @return array
     */
    public function insert_dataplus_record($columns) {
        global $USER, $currentgroup;

        $i = count($columns);

        $columns[$i] = new stdClass();
        $columns[$i]->name  = 'creator';
        $columns[$i]->value = $USER->firstname.' '.$USER->lastname;

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name  = 'creator_id';
        $columns[$i]->value = $USER->id;

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name  = 'created_time';
        $columns[$i]->value = time();

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name  = 'last_update';
        $columns[$i]->value = $USER->firstname.' '.$USER->lastname;

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name  = 'last_update_id';
        $columns[$i]->value = $USER->id;

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name  = 'last_update_time';
        $columns[$i]->value = time();

        return $this->insert_record('content', $columns);
    }


    /**
     * delete records.  If no parameters are set, all records will be deleted.
     *
     * @param array $parameters
     * @return boolean
     */
    public function delete_dataplus_record($parameters = null) {
        return $this->delete_record('content', $parameters);
    }


    /**
     * Make changes to a user template.
     *
     * @param array $template
     * @return boolean
     */
    public function update_template($template) {
        foreach ($template as $t) {
            if ($t->name == 'type') {
                $type = $t->value;
            }

            if ($t->name == 'group_id') {
                $groupid = $t->value;
            }
        }

        $exists = $this->get_template($type, false);

        if (empty($exists)) {
            return $this->insert_record('templates', $template);
        }

        $parameters = array(new stdClass());
        $parameters[0]->name = 'type';
        $parameters[0]->value = $type;
        $parameters[0]->operator = 'equals';

        $parameters[1] = new stdClass();
        $parameters[1]->name = 'group_id';
        $parameters[1]->value = $groupid;
        $parameters[1]->operator = 'equals';
        $parameters[1]->andor = 'AND';

        return $this->update_record('templates', $template, $parameters);
    }


    /**
     * make changes to an existing columns specified of a record or records according to parameters
     *
     * @param array $columns
     * @param array $parameters
     * @return boolean
     */
    public function update_dataplus_record($columns, $parameters = array()) {
        global $USER, $currentgroup;

        $i = count($columns);
        $columns[$i] = new stdClass();
        $columns[$i]->name = 'last_update';
        $columns[$i]->value = $USER->firstname.' '.$USER->lastname;

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name = 'last_update_id';
        $columns[$i]->value = $USER->id;

        $i++;
        $columns[$i] = new stdClass();
        $columns[$i]->name = 'last_update_time';
        $columns[$i]->value = time();

        return $this->update_record('content', $columns, $parameters);
    }


    /**
     * return a template from the database.  In groups mode, if no template for the current
     * group is found, this function will look for a template set to 'all participants'.
     *
     * @param string $type
     * @param boolean $checkparticipants
     * @return mixed
     */
    public function get_template($type, $checkparticipants = true) {
        global $currentgroup;

        $columns = array('header',
                         'record',
                         'footer',
                         'js',
                         'jsinit',
                         'css',
                         'comments',
                         'sortorder');

        $parameters = array(new stdClass());
        $parameters[0]->name = 'type';
        $parameters[0]->value = $type;
        $parameters[0]->operator = 'equals';

        $parameters[1] = new stdClass();
        $parameters[1]->name = 'group_id';
        $parameters[1]->value = $currentgroup;
        $parameters[1]->operator = 'equals';
        $parameters[1]->andor = 'AND';

        $template = $this->query_database('templates', $columns, $parameters);

        if ($checkparticipants && empty($template)) {
            $parameters[1]->name = 'group_id';
            $parameters[1]->value = '0';
            $parameters[1]->operator = 'equals';
            $parameters[1]->andor = 'AND';

            $template = $this->query_database('templates', $columns, $parameters);
        }

        if ($checkparticipants && empty($template)) {
            $parameters[1]->name = 'group_id';
            $parameters[1]->value = '';
            $parameters[1]->operator = 'equals';
            $parameters[1]->andor = 'AND';

            $template = $this->query_database('templates', $columns, $parameters);
        }

        if (empty($template)) {
            return false;
        } else {
            return $template[0];
        }
    }


    /**
     * gets all the templates from the database
     *
     * @return array
     */
    public function get_templates() {
        $columns = array('id', 'header', 'record', 'footer', 'type', 'group_id', 'comments');
        $templates = $this->query_database('templates', $columns);

        return $templates;
    }


    /**
     * deletes all templates from the current group (if applicable) of a given type
     *
     * @param string $type
     * @return unknown
     */
    public function delete_template($type) {
        global $currentgroup;

        $delparams = array(new stdClass());
        $delparams[0]->name = 'group_id';
        $delparams[0]->value = $currentgroup;
        $delparams[0]->operator = 'equals';

        $delparams[1] = new stdClass();
        $delparams[1]->name = 'type';
        $delparams[1]->value = $type;
        $delparams[1]->operator = 'equals';

        return $this->delete_record('templates', $delparams);
    }


    /**
     * return a query containing given columns to given parameters to a set limit in
     * a particular order. Should return everything if no params are set
     *
     * @param array $columns
     * @param array $parameters
     * @param array $limit
     * @param array $order
     * @return object
     */
    public function query_dataplus_database($columns = null,
                                            $parameters = null,
                                            $limit = null,
                                            $order = null) {
        if (is_null($columns)) {
            $coldetails = $this->list_dataplus_table_columns(true);

            foreach ($coldetails as $cd) {
                $columns[] = $cd->name;
            }
        }

        return $this->query_database('content', $columns, $parameters, $limit, $order);
    }


    /**
     * Returns a single result (if the query returns more than one result then the first
     * result is returned).
     *
     * @param array $columns
     * @param array $parameters
     * @param array $order
     * @return object
     */
    public function query_dataplus_database_single($columns = null,
                                                   $parameters = null,
                                                   $order = null) {
        if (is_null($columns)) {
            $coldetails = $this->list_dataplus_table_columns(true);
            $columns = array();
            foreach ($coldetails as $cd) {
                $columns[] = $cd->name;
            }
        }

        return $this->query_database_single('content', $columns, $parameters, $order);
    }


    /**
     * Counts the results of a query
     *
     * @param array $parameters
     * @return int
     */
    public function count_dataplus_database_query($parameters = null) {
        return $this->count_database_query('content', $parameters);
    }


    /**
     * Changes all the dates in the database to UK dates.
     *
     * @return boolean
     */
    public function generate_uk_dates() {
        $cols = $this->list_dataplus_table_columns(true);
        $datecols = array();
        $datetimecols = array();

        foreach ($cols as $col) {
            if ($col->type == 'date') {
                $datecols[] = $col->name;
            } else if ($col->type == 'datetime') {
                $datetimecols[] = $col->name;
            }
        }

        $allcols = array_merge($datetimecols, $datecols);
        $allcols[] = 'id';
        $records = $this->query_dataplus_database($allcols);

        foreach ($records as $record) {
            $parameters = array(new stdClass());
            $parameters[0]->name = 'id';
            $parameters[0]->value = $record->id;
            $parameters[0]->operator = 'equals';

            $update = array();

            $i = 0;

            foreach ($datecols as $d) {
                if (!empty($record->$d)) {
                    $update[$i] = new stdClass();
                    $update[$i]->name = $d;
                    $update[$i]->value = date('d/m/Y', $record->$d);
                    $i++;
                }
            }

            foreach ($datetimecols as $d) {
                if (!empty($record->$d)) {
                    $update[$i] = new stdClass();
                    $update[$i]->name = $d;
                    $update[$i]->value = date('d/m/Y H:i:s', $record->$d);
                    $i++;
                }
            }

            if (!empty($update) && !$this->update_record('content', $update, $parameters)) {
                return false;
            }
        }

        return true;
    }


    /**
     * @return array of field names that can't be used.
     */
    protected function get_reserved_field_names() {
        return array('id', 'moodledprating', 'ratingdptemp');
    }


    /**
     * check whether a field name is reserved.
     * @param $fieldname
     * @return boolean
     */
    public function check_column_name_reserved($fieldname) {
        return in_array($fieldname, $this->get_reserved_field_names());
    }


    /**
     * Checks to see if there are any records or columns in the database
     *
     * @return boolean
     */
    public function unused_database() {
        $records = $this->count_dataplus_database_query();

        if ($records > 0) {
            return false;
        }

        $columns = $this->count_database_query('column');

        if ($columns > count($this->detail_content_table_supporting_columns())) {
            return false;
        }

        return true;
    }


    /**
     * deletes all the user generated data from a database
     *
     * @return boolean
     */
    public function empty_user_data() {
        if (!$this->delete_dataplus_record()) {
            return false;
        }

        return true;
    }


    /**
     * returns the number of entries created by a particular user
     *
     * @return int
     */
    public function count_user_entries() {
        global $USER;

        $parameters = array(new stdClass());
        $parameters[0]->name = 'creator_id';
        $parameters[0]->value = $USER->id;
        $parameters[0]->operator = 'equals';

        return $this->count_dataplus_database_query($parameters);
    }


    /**
     * count the number of user generated fields in a database
     *
     * @return int
     */
    public function count_user_fields() {
        $supportingcols = $this->detail_content_table_supporting_columns();
        $parameters = array();

        foreach ($supportingcols as $col) {
            $s = count($parameters);
            $parameters[$s] = new stdClass();
            $parameters[$s]->name = 'name';
            $parameters[$s]->value = $col->name;
            $parameters[$s]->operator = 'notequal';
            $parameters[$s]->andor = 'AND';
        }

        return $this->count_database_query('column', $parameters);
    }


    /**
     * Get the id of last record edited by a user
     * param $userid
     *
     * @return int
     */
    public function get_user_last_record_id($userid = null) {
        if (empty($userid)) {
            global $USER;
            $userid = $USER->id;
        }

        $parameters = array(new stdClass());
        $parameters[0]->name = 'last_update_id';
        $parameters[0]->value = $userid;

        $order = array(new stdClass());
        $order[0]->name = 'last_update_time';
        $order[0]->sort = 'DESC';

        $result = $this->query_dataplus_database_single(array('id'), $parameters, $order);

        if (!$result) {
            return false;
        }

        return (int) $result->id;
    }


    /**
     * Get the ids of the records created by a user
     * param $userid
     *
     * @return array
     */
    public function get_user_record_ids($userid) {
        if (empty($userid)) {
            global $USER;
            $userid = $USER->id;
        }

        $parameters = array(new stdClass());
        $parameters[0]->name = 'creator_id';
        $parameters[0]->value = $userid;

        $result = $this->query_dataplus_database(array('id'), $parameters);

        if (!$result) {
            return false;
        }

        $ids = array();
        foreach ($result as $r) {
            $ids[] = $r->id;
        }

        return $ids;
    }

    /**
     * Get the id of the next record to be entered
     * @return int
     */
    public function get_next_record_id() {
        if (!empty($this->nextrecordid)) {
            return $this->nextrecordid;
        }
        $order = array(new stdClass());
        $order[0]->name = 'id';
        $order[0]->sort = 'DESC';
        $order[0]->type = 'int';

        $result = $this->query_dataplus_database_single(array('id'), array(), $order);

        if (!$result) {
            // If there's nothing there, create a dummy record...
            $this->insert_dataplus_record(array());
            $result = $this->query_dataplus_database_single(array('id'));
            // Delete the dummy.
            $parameters = array();
            $parameters[0] = new stdClass();
            $parameters[0]->name = 'id';
            $parameters[0]->value = $result->id;
            $this->delete_dataplus_record($parameters);
        }

        $this->nextrecordid = ((int)$result->id) + 1;
        return $this->nextrecordid;
    }


    /**
     * converts a query result into values compatible for database edits or updates
     *
     * @param obj $obj
     * @return array
     */
    public function convert_object_to_values($obj) {
        $ar = array();
        $i = 0;

        foreach ($obj as $name => $value) {
            $ar[$i] = new stdClass();
            $ar[$i]->name = $name;
            $ar[$i]->value = $value;
            $i++;
        }

        return $ar;
    }


    /**
     * Converts the fields from user ids to usernames
     *
     * @param string field_name
     * @return boolean
     */
    public function ids_to_usernames($fieldname) {
        $updates = $this->query_dataplus_database(array($fieldname));
        $updatesdone = $update = array();

        foreach ($updates as $u) {
            if (in_array($u->$fieldname, $updatesdone)) {
                continue;
            }

            $update[0] = new stdClass();
            $userdata = get_complete_user_data('id', $u->$fieldname);
            $updatesdone[] = $u->$fieldname;
            $update[0]->name  = $fieldname;

            if (!$userdata) {
                $update[0]->value = "UNKNOWN";
            } else {
                $update[0]->value = $userdata->username;
            }

            $parameters = array(new stdClass());
            $parameters[0]->name = $fieldname;
            $parameters[0]->value = $u->$fieldname;
            $parameters[0]->operator = 'equals';

            if ($this->update_record('content', $update, $parameters)) {
                continue;
            } else {
                return false;
            }
        }

        return true;
    }


    /**
     * get comment table column names
     * @return array
     */
    public function get_comment_column_names() {
        return array('id',
                     'comment',
                     'group_id',
                     'creator',
                     'creator_id',
                     'created_time',
                     'last_update',
                     'last_update_id',
                     'last_update_time');
    }

    /**
     * insert a comment to the comment table.
     *
     * @param int $recordid
     * @param string $comment
     * @param string $groupid
     * @return boolean
     */
    public function insert_comment($recordid, $comment) {
        global $USER, $currentgroup;

        $columns = array(new stdClass());
        $columns[0]->name = 'creator';
        $columns[0]->value = $USER->firstname.' '.$USER->lastname;

        $columns[1] = new stdClass();
        $columns[1]->name = 'creator_id';
        $columns[1]->value = $USER->id;

        $columns[2] = new stdClass();
        $columns[2]->name = 'created_time';
        $columns[2]->value = time();

        $columns[3] = new stdClass();
        $columns[3]->name = 'last_update';
        $columns[3]->value = $USER->firstname.' '.$USER->lastname;

        $columns[4] = new stdClass();
        $columns[4]->name = 'last_update_id';
        $columns[4]->value = $USER->id;

        $columns[5] = new stdClass();
        $columns[5]->name = 'last_update_time';
        $columns[5]->value = time();

        $columns[6] = new stdClass();
        $columns[6]->name = 'record_id';
        $columns[6]->value = $recordid;

        $columns[7] = new stdClass();
        $columns[7]->name = 'comment';
        $columns[7]->value = $comment;

        $columns[8] = new stdClass();
        $columns[8]->name = 'group_id';
        $columns[8]->value = $currentgroup;

        return $this->insert_record('comments', $columns);
    }

    /**
     * deletes a comment
     *
     * @param int $id
     * @return boolean
     */
    public function delete_comment($id) {
        global $currentgroup;

        $params = array(new stdClass());
        $params[0]->name = 'id';
        $params[0]->value = $id;
        $params[0]->operator = 'equals';

        return $this->delete_record('comments', $params);
    }


    /**
     * Make changes to a user comment.
     *
     * @param int $id
     * @param string $comment
     * return boolean
     */
    public function update_comment($id, $comment) {
        global $USER;

        $columns = array(new stdClass());
        $columns[0]->name = 'comment';
        $columns[0]->value = $comment;

        $columns[1] = new stdClass();
        $columns[1]->name = 'last_update';
        $columns[1]->value = $USER->firstname.' '.$USER->lastname;

        $columns[2] = new stdClass();
        $columns[2]->name = 'last_update_id';
        $columns[2]->value = $USER->id;

        $columns[3] = new stdClass();
        $columns[3]->name = 'last_update_time';
        $columns[3]->value = time();

        $parameters = array(new stdClass());
        $parameters[0]->name = 'id';
        $parameters[0]->value = $id;
        $parameters[0]->operator = 'equals';

        return $this->update_record('comments', $columns, $parameters);
    }


    /**
     * return a comment from the database.
     *
     * @param int $id
     * @return mixed
     */
    public function get_comment($id, $additionalparams = null) {
        global $currentgroup;

        $columns = $this->get_comment_column_names();

        $parameters = array(new stdClass());
        $parameters[0]->name = 'id';
        $parameters[0]->value = $id;
        $parameters[0]->operator = 'equals';

        if (!is_null($additionalparams)) {
            $parameters = array_merge($parameters, $additionalparams);
        }

        $comment = $this->query_database('comments', $columns, $parameters);

        if (empty($comment)) {
            return false;
        } else {
            return $comment[0];
        }
    }


    /**
     * return all the comments for a particular record
     *
     * @param int $rid
     * @return array
     */
    public function get_record_comments($rid,
                                        $end = null,
                                        $start = null,
                                        $additionalparams = null) {
        global $currentgroup;

        $columns = $this->get_comment_column_names();

        $parameters = array(new stdClass());
        $parameters[0]->name = 'record_id';
        $parameters[0]->value = $rid;
        $parameters[0]->operator = 'equals';

        if (!is_null($end)) {
            $parameters[1] = new stdClass();
            $parameters[1]->name = 'id';
            $parameters[1]->value = $end;
            $parameters[1]->operator = 'lessthan';
            $parameters[1]->andor = 'AND';
        }

        if (!is_null($start)) {
            $val = count($parameters) + 1;
            $parameters[$val] = new stdClass();
            $parameters[$val]->name = 'id';
            $parameters[$val]->value = $start;
            $parameters[$val]->operator = 'greaterthan';
            $parameters[$val]->andor = 'AND';
        }

        if (!is_null($additionalparams)) {
            $parameters = array_merge($parameters, $additionalparams);
        }

        $comments = $this->query_database('comments', $columns, $parameters);

        if (empty($comments)) {
            return false;
        } else {
            return $comments;
        }
    }


    /**
     * returns the id of a content column in the column table
     * @param string $name
     *
     * @return int
     */
    public function get_content_column_id($name) {
        $parameters = array(new stdClass());
        $parameters[0]->name = 'name';
        $parameters[0]->value = $name;
        $result = $this->query_database('column', array('id'), $parameters);

        return (int) $result[0]->id;
    }


    /**
     * returns an array of the names of all the  columns of a given type
     */
    public function list_columns_of_type($type) {
        $parameters = array(new stdClass());
        $parameters[0]->name = 'form_field_type';
        $parameters[0]->value = $type;

        $colsobjs = $this->query_database('column', array('name'), $parameters);

        $cols = array();

        foreach ($colsobjs as $obj) {
            $cols[] = $obj->name;
        }

        return $cols;
    }
}